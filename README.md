### Для чего?
Ну собственно идея и, частично реализация, скопипазжена у активного пользователя [телеграмм канала @mysensors_rus](https://t.me/mysensors_rus "телеграмм канала @mysensors_rus") Андрея (Andrew, aka Berk, Berkseo, EfektaLab на других популярных DIY-ресурсах).
Идея, по его же словам [в статье на хабре](https://habr.com/ru/post/478960/ "в статье на хабре"), звучит так:
> Многие кто уже использует проект MySensors для построения своего Умного Дома наверное знают о неоптимальной логике работы MySensors на батарейных устройствах. Постоянная отправка презентаций при перезагрузке устройства, неоптимальный режим автоматического восстановления работы устройств в сети, неоптимальное потребление при активированных прерываниях в функции сна, вообще в целом само наличие только двух прерываний во сне. Все обстоятельства как специально намекают на то что основатели проекта Майсенсорс плохо относятся к батарейкам :)

На самом деле, хотелось просто разобраться в коде, для дальнейшего использования в своих проектах. В результате, получилось, чтобы разобраться - пришлось переписать все с нуля. Заодно оформить это в виде библиотечки через подключаемые файлы. Кроме того в библиотеку включены ряд идей, которые обсуждались на канале, но не были реализованы Андреем и добавлено несколько методов, которые по моему скромному усмотрению весьма востребованы.

### Теперь по порядку
- Режим "счастливой ноды" с режимом "счастливой презентации"
- Режим низкопотребляющего сна с любым количеством пинов
- Опциональная закадровая "умная передача состояния батереи" с опциональной передачей вольтажа
- Опциональная закадровая передача уровня сигнала
- Опциональная закадровая передача причины рестарта ноды (естественно при рестарте)
- Редкий умный сон (только через заданное время, независимое, но кратное времени сна) в разработке

Я постарался реализовать не только, чтобы пользоваться было удобно: все обращения в стиле MySensors, минимальный дополнительный код, дублирование обращений ООП простым процедурным стилем, но 
и чтобы реализация была максимально прозрачной, для возможной дальнейшей коллективной доработки. Я конечно Ритчи с Керниганом наизусть не знаю и со Страуструпом в обнимку не сплю, тем не менее С++ люблю
и стараюсь понимать. Кроме того я придерживаюсь некого самопального стандарта, который делает, как мне кажется мой код более легким в понимании и отладке:
- форматирование текста строго табуляциями, выделение логических модулей пустыми строками
- переменный объявлять как можно ближе к месту их использования, глобальные и общеклассовые перемменые должны быть минимизированы. 
- Короткие имена переменных - зло. Переменные именуются по следующему стандарту: ЭТО_МАКРОСЫ_ПРЕПРОЦЕССОРА, это_вызовы_из_с_библиотек, этоВсёОстальное.
